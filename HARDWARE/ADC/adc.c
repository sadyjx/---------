#include "adc.h"
#include "delay.h"					   
//////////////////////////////////////////////////////////////////////////////////	 
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK战舰STM32开发板
//ADC 代码	   
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//修改日期:2012/9/7
//版本：V1.1
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2009-2019
//All rights reserved									  
//********************************************************************************
//V1.1 20120907
//在Adc_Init函数增加了内部温度测量的初始化参数。									  
////////////////////////////////////////////////////////////////////////////////// 
	   
//初始化ADC
//这里我们仅以规则通道为例
//我们默认仅开启通道1																	   
void  Adc_Init(void)
{    
	//先初始化IO口
 	RCC->APB2ENR|=1<<2;    //使能PORTA口时钟 

	GPIOA->CRL&=0XF0FFFFFF; 
	GPIOA->CRL|=0X03000000;	//PB9 推挽 	    
	GPIOA->ODR|=1<<6;     	//PB9 上拉	输出高
	ADC_VCC=1;

	GPIOA->CRL&=0XFFFFFFF0;//PA1 anolog输入

	//通道10/11设置			 
	RCC->APB2ENR|=1<<9;    //ADC1时钟使能	  
	RCC->APB2RSTR|=1<<9;   //ADC1复位
	RCC->APB2RSTR&=~(1<<9);//复位结束	    
	RCC->CFGR&=~(3<<14);   //分频因子清零	
	//SYSCLK/DIV2=12M ADC时钟设置为12M,ADC最大时钟不能超过14M!
	//否则将导致ADC准确度下降! 
	RCC->CFGR|=2<<14;      	 
	ADC1->CR1&=0XF0FFFF;   //工作模式清零
	ADC1->CR1|=0<<16;      //独立工作模式  
	ADC1->CR1&=~(1<<8);    //非扫描模式	  
	ADC1->CR2&=~(1<<1);    //单次转换模式
	ADC1->CR2&=~(7<<17);	   
	ADC1->CR2|=7<<17;	   //软件控制转换  
	ADC1->CR2|=1<<20;      //使用用外部触发(SWSTART)!!!	必须使用一个事件来触发
	ADC1->CR2&=~(1<<11);   //右对齐	 
	ADC1->CR2|=1<<23;      //使能温度传感器

	ADC1->SQR1&=~(0XF<<20);
	ADC1->SQR1&=0<<20;     //1个转换在规则序列中 也就是只转换规则序列1 			   
	//设置通道1的采样时间
	ADC1->SMPR2&=~(7<<3);  //通道1采样时间清空	  
 	ADC1->SMPR2|=7<<3;     //通道1  239.5周期,提高采样时间可以提高精确度	 

 	ADC1->SMPR1&=~(7<<18);  //清除通道16原来的设置	 
	ADC1->SMPR1|=7<<18;     //通道16  239.5周期,提高采样时间可以提高精确度	 

	ADC1->CR2|=1<<0;	   //开启AD转换器	 
	ADC1->CR2|=1<<3;       //使能复位校准  
	while(ADC1->CR2&1<<3); //等待校准结束 			 
    //该位由软件设置并由硬件清除。在校准寄存器被初始化后该位将被清除。 		 
	ADC1->CR2|=1<<2;        //开启AD校准	   
	while(ADC1->CR2&1<<2);  //等待校准结束
	//该位由软件设置以开始校准，并在校准结束时由硬件清除  
}				  
//获得ADC值
//ch:通道值 0~16
//返回值:转换结果
u16 Get_Adc(u8 ch)   
{
	//设置转换序列	  		 
	ADC1->SQR3&=0XFFFFFFE0;//规则序列1 通道ch
	ADC1->SQR3|=ch;		  			    
	ADC1->CR2|=1<<22;       //启动规则转换通道 
	while(!(ADC1->SR&1<<1));//等待转换结束	 	   
	return ADC1->DR;		//返回adc值	
}
//获取通道ch的转换值，取times次,然后平均 
//ch:通道编号
//times:获取次数
//返回值:通道ch的times次转换结果平均值
u16 Get_Adc_Average(u8 ch,u8 times)
{
	u32 temp_val=0;
	u8 t;
	for(t=0;t<times;t++)
	{
		temp_val+=Get_Adc(ch);
		delay_us(10);
	}
	return temp_val/times;
} 
	 

//  MF52 10K at 25, B = 3950, ADC = 12 bits
static u16  temp_table[]={
        358,    //;50  0
        372,    //;49  1
        387,    //;48  2
        402,    //;47  3
        418,    //;46  4
        435,    //;45  5
        453,    //;44  6
        471,    //;43  7
        490,    //;42  8
        510,    //;41  9
        531,    //;40  10
        553,    //;39  11
        576,    //;38  12
        600,    //;37  13
        626,    //;36  14
        652,    //;35  15
        680,    //;34  16
        709,    //;33  17
        739,    //;32  18
        771,    //;31  19
        804,    //;30  20
        839,    //;29  21
        876,    //;28  22
        915,    //;27  23
        955,    //;26  24
        1000,    //;25  25
        1043,    //;24  26
        1090,    //;23  27
        1139,    //;22  28
        1191,    //;21  29
        1246,    //;20  30
        1303,    //;19   31
        1364,    //;18   32
        1427,    //;17   33
        1494,    //;16   34
        1565,    //;15   35
        1639,    //;14   36
        1717,    //;13   37
        1800,    //;12   38
        1886,    //;11   39
        1978,    //;10    40
        2074,   //;9    41
        2176,   //;8    42
        2283,   //;7    43
        2396,   //;6    44
        2515,   //;5    45
        2640,   //;4    46
        2773,   //;3    47
        2912,   //;2    48
        3060,   //;1    49
        3211,   //;0   50

};

/********************  计算温度 ***********************************************/
// 计算结果: 0对应-40.0度, 400对应0度, 625对应25.0度, 最大1600对应120.0度. 
// 为了通用, ADC输入为12bit的ADC值.
// 电路和软件算法设计: Coody
/**********************************************/

#define     D_SCALE     10      //结果放大倍数, 放大10倍就是保留一位小数
u16 get_temperature(u16 adc)
{
    u16 static *p;
    u16 i;
    u8  j,k,min,max;
    
//    adc = adc+8;   //Rt接地 
  
    p = temp_table;
    if(adc < p[0])      return (0xfffe);
    if(adc > p[50])    return (0xffff);
    
    min = 0;        //-40度
    max = 50;      //120度

    for(j=0; j<5; j++)  //对分查表
    {
        k = min / 2 + max / 2;
        if(adc <= p[k]) max = k;
        else            min = k;
    }
         if(adc == p[min])  i = min * D_SCALE;
    else if(adc == p[max])  i = max * D_SCALE;
    else    // min < temp < max
    {
        while(min <= max)
        {
            min++;
            if(adc == p[min])   {i = min * D_SCALE; break;}
            else if(adc < p[min])
            {
                min--;
                i = p[min]; //min
                j = (adc - i) * D_SCALE / (p[min+1] - i);
                i = min;
                i *= D_SCALE;
                i += j;
                break;
            }
        }
    }
    return i;
}







